#version 450 core

#include "StructInclude.glsl"
#include "Defines.glsl"
#include "PBR.glsl"

layout(local_size_x = THREAD_GROUP_SIZE, local_size_y = THREAD_GROUP_SIZE, local_size_z = 1) in;

layout(set = 1, binding = 0) uniform GlobalData
{
	mat4 jitteredVP;
	mat4 VP;

	mat4 prevVP;
	vec4 viewPos;
	mat4 invProj;
	mat4 invView;
	mat4 view;
	mat4 proj;
} global;

layout(set = 0, binding = 1) readonly buffer SceneData
{
	uint hasDirectionalLight; 
	uint lightCount;

	float padding[2];

	DirectionalLight dirLight;
	PointLight[] pointLight;
} sceneData;

layout(set = 0, binding = 2) uniform sampler2D gColour;
layout(set = 0, binding = 3) uniform sampler2D gNormal;

layout(set = 0, binding = 4, rgba8) uniform image2D finalOutput;

layout(set = 0, binding = 5) uniform sampler2D gDepth;
layout(set = 0, binding = 6) uniform sampler2D gEmissive;

layout(set = 2, binding = 0) uniform ShadowData
{
	mat4 matrices[CASCADE_COUNT];
	vec4 splitDepths;
} shadowData;

layout(set = 2, binding = 1) uniform sampler2DShadow cascadeAtlas;

layout(set = 3, binding = 0) uniform samplerCube irradianceCube;

layout(push_constant) uniform PushConstants
{
	int useIBL;
} constants;

struct Material
{
	vec3 albedo;
	float roughness; 
	float metallic;
} material;

uint cascadeIndex = 0;

const mat4 biasMat = mat4( 
	0.5, 0.0, 0.0, 0.0,
	0.0, 0.5, 0.0, 0.0,
	0.0, 0.0, 1.0, 0.0,
	0.5, 0.5, 0.0, 1.0 
);

/*float sampleVariance(vec2 coords, float compare)
{
	vec2 moments = texture(cascadeAtlas, coords.xy).xy;

	float p = step(compare, moments.x);
	float variance = max(moments.y - moments.x * moments.x, 0.00002);

	float d = compare - moments.x;
	float pMax = variance / (variance + d*d);

	return min(max(p, pMax), 1.0);
}*/	

const float cascadeBlend = 0.8;

float textureProj(vec4 shadowCoord, vec2 offset, uint cascadeIndex, float bias)
{
	float shadow = 1.0;

	if ( shadowCoord.z > -1.0 && shadowCoord.z < 1.0 ) {

		vec2 sampleCoord = shadowCoord.st + offset;

		float cascadeSize = 1.0 / 3.0;
		
		sampleCoord.x /= 3;

		sampleCoord.x += cascadeSize * cascadeIndex;

		/*float dist = texture(cascadeAtlas, sampleCoord).r;
		if (shadowCoord.w > 0 && dist < shadowCoord.z - bias) {
			shadow = 0.0;
		}*/

		shadow = texture(cascadeAtlas, vec3(sampleCoord, shadowCoord.z - bias));

		//shadow = sampleVariance(sampleCoord, shadowCoord.z - bias);
	}
	return shadow;

}

float filterPCF(vec4 sc, uint cascadeIndex, float bias)
{
	if (cascadeIndex > 1)
		return textureProj(sc, vec2(0, 0), cascadeIndex, bias);

	ivec2 texDim = textureSize(cascadeAtlas, 0).xy;
	texDim.x /= 3;
	float scale = 1.2;
	float dx = scale * 1.0 / float(texDim.x);
	float dy = scale * 1.0 / float(texDim.y);

	float shadowFactor = 0.0;
	int count = 0;
	int range = (cascadeIndex == 0)? 2 : 1;
	
	for (int x = -range; x <= range; x++) {
		for (int y = -range; y <= range; y++) {
			shadowFactor += textureProj(sc, vec2(dx*x, dy*y), cascadeIndex, bias);
			count++;
		}
	}
	return shadowFactor / count;
}





vec4 shadowCoord;

vec3 DirectionalLightContribution(vec3 n, DirectionalLight light, vec3 v, vec3 f0, vec3 fragPos)
{
	vec3 l = normalize(light.direction.xyz);

	// Shadow

	vec4 viewPos = global.view *  vec4(fragPos, 1.0);

	// Get cascade index
	//uint cascadeIndex = 0;
	for(uint i = 0; i < CASCADE_COUNT - 1; ++i) {
		if(viewPos.z < shadowData.splitDepths[i]) {	
			cascadeIndex = i + 1;
		}
	}

	//cascadeIndex = 0;

	shadowCoord = (biasMat * shadowData.matrices[cascadeIndex]) * vec4(fragPos, 1.0);	

	float bias = 0.005;  

	float shadow = 0;
	if (constants.useIBL==1)
		//shadow = textureProj(shadowCoord / shadowCoord.w, vec2(0.0), cascadeIndex, bias);
		shadow = filterPCF(shadowCoord / shadowCoord.w, cascadeIndex, bias);

	

	vec3 h = normalize(v + l);

    float NoV = abs(dot(n, v)) + 1e-5;
    float NoL = clamp(dot(n, l), 0.0, 1.0);
    float NoH = clamp(dot(n, h), 0.0, 1.0);
    float LoH = clamp(dot(l, h), 0.0, 1.0);

	vec3 radiance = light.colour.xyz;

	float roughness = material.roughness * material.roughness;

	//vec3 Fd = light.colour.xyz * Diffuse_Burley(NoV, NoL, LoH, roughness);

    float D = GGX(NoH, roughness);
    vec3  F = Schlick(LoH, f0);
    float V = GeometrySmith(n, v, l, roughness);

	vec3 Spec = F;
	vec3 Diffuse = vec3(1.0) - F;
	Diffuse *= 1.0 - material.metallic;

	vec3 num = Spec * D * V;
	float dem = 4 * max(NoV, 0.1) * max(NoL, 0.0) + 0.001;

	vec3 Fr = num / dem;

	vec3 Fd = Diffuse * Diffuse_Lambert();

	vec3 luminance = (Fd + Fr) * radiance * NoL * shadow;

	return luminance; 
}

void main()
{

	ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
	ivec2 imgSize = ivec2(imageSize(finalOutput));

	if (coord.x > imgSize.x || coord.y > imgSize.y)
		return;

	vec3 prev = imageLoad(finalOutput, coord).xyz;

	vec2 uv = vec2(coord) / vec2(imageSize(finalOutput));

	float depth = texelFetch(gDepth, coord, 0).r;
	vec3 fragPos = WorldPosFromDepth(depth, global.invProj, global.invView, uv);

	vec3 v = normalize(global.viewPos.xyz - fragPos);
	

	// Fetch the target colours
	vec4 gColourSampled = texelFetch(gColour, ivec2(gl_GlobalInvocationID.xy), 0);
	vec4 gNormalSampled = texelFetch(gNormal, ivec2(gl_GlobalInvocationID.xy), 0);

	material.roughness = max(gNormalSampled.b, 0.04); 
	material.metallic = gNormalSampled.a;

	vec2 encodedNormal = gNormalSampled.xy;
	vec3 normal = normalize(decode(encodedNormal));

	vec3 irradiance = vec3(0.15);

	if (constants.useIBL == 1)
		irradiance = texture(irradianceCube, normal).rgb;

	// Normal is encoded in 2 channels so it needs to be decoded back into xyz
	material.albedo = gColourSampled.xyz;

	vec3 ambient = irradiance * gColourSampled.a;

	vec3 f0 = vec3(0.04); 
	f0 = mix(f0, material.albedo, material.metallic);

	vec3 lightContribution = vec3(0.0);

	lightContribution += DirectionalLightContribution(normal, sceneData.dirLight, v, f0, fragPos) * float(sceneData.hasDirectionalLight);

	// Compute ambient contribution

	vec3 ambientLight = material.albedo * ambient;

	vec3 final = ambientLight + material.albedo * lightContribution;
	final += texelFetch(gEmissive, coord, 0).xyz;

	// Debug

	/*switch(cascadeIndex)
	{
	case 0: final = vec3(0.0, 1.0, 0.0); break;
	case 1: final = vec3(0.0, 0.0, 1.0); break;
	case 2: final = vec3(1.0, 0.0, 0.0); break;
	}*/

	// Store the final result to the output image
	if (depth != DEPTH_MAX)
		imageStore(finalOutput, ivec2(gl_GlobalInvocationID.xy), vec4(final, 1.0));
	else 
		imageStore(finalOutput, coord, vec4(prev, 1.0));
	
}