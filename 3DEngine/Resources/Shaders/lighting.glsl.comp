#version 450 core

#include "StructInclude.glsl"
#include "Defines.glsl"
#include "PBR.glsl"

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 1, binding = 0) uniform GlobalData
{
	mat4 jitteredVP;
	mat4 VP;

	mat4 prevVP;
	vec4 viewPos;
	mat4 invProj;
	mat4 invView;
	mat4 view;
	mat4 proj;
} global;

layout(set = 0, binding = 1) readonly buffer SceneData
{
	uint hasDirectionalLight; 
	uint lightCount;

	float padding[2];

	DirectionalLight dirLight;
	PointLight[] pointLight;
} sceneData;

layout(set = 0, binding = 2) uniform sampler2D gColour;
layout(set = 0, binding = 3) uniform sampler2D gNormal;

layout(set = 0, binding = 4, rgba8) uniform image2D finalOutput;

layout(set = 0, binding = 5) uniform sampler2D gDepth;


struct Material
{
	vec3 albedo;
	float roughness; 
	float metallic;
} material;

vec3 DirectionalLightContribution(vec3 n, DirectionalLight light, vec3 v, vec3 f0)
{
	vec3 l = light.direction.xyz;

	vec3 h = normalize(v + l);

    float NoV = abs(dot(n, v)) + 1e-5;
    float NoL = clamp(dot(n, l), 0.0, 1.0);
    float NoH = clamp(dot(n, h), 0.0, 1.0);
    float LoH = clamp(dot(l, h), 0.0, 1.0);

	vec3 Fd = light.colour.xyz * Diffuse_Lambert();

	float roughness = material.roughness * material.roughness;

	//vec3 Fd = light.colour.xyz * Diffuse_Burley(NoV, NoL, LoH, roughness);

    float D = GGX(NoH, roughness);
    vec3  F = Schlick(LoH, f0);
    float V = SmithGGXCorrelated(NoV, NoL, roughness);

    // specular BRDF
    vec3 Fr = (D * V) * F;


	vec3 luminance = (Fd + Fr) * NoL;

	return luminance; 
}

void main()
{

	ivec2 coord = ivec2(gl_GlobalInvocationID.xy);

	vec3 prev = imageLoad(finalOutput, coord).xyz;

	vec2 uv = vec2(coord) / vec2(imageSize(finalOutput));

	float depth = texelFetch(gDepth, coord, 0).r;
	vec3 fragPos = WorldPosFromDepth(depth, global.invProj, global.invView, uv);

	vec3 v = normalize(global.viewPos.xyz - fragPos);
	

	// Fetch the target colours
	vec4 gColourSampled = texelFetch(gColour, ivec2(gl_GlobalInvocationID.xy), 0);
	vec4 gNormalSampled = texelFetch(gNormal, ivec2(gl_GlobalInvocationID.xy), 0);

	// Albedo is the first 3 channels of the target
	material.albedo = gColourSampled.xyz;

	// Normal is encoded in 2 channels so it needs to be decoded back into xyz
	vec2 encodedNormal = gNormalSampled.xy;
	vec3 normal = normalize(decode(encodedNormal));

	material.roughness = gNormalSampled.b; 
	material.metallic = gNormalSampled.a;

	vec3 f0 = vec3(0.04); 
	f0 = mix(f0, material.albedo, material.metallic);

	vec3 lightContribution = vec3(0.0);

	lightContribution += DirectionalLightContribution(normal, sceneData.dirLight, v, f0) * float(sceneData.hasDirectionalLight);

	vec3 final = material.albedo * lightContribution;

	

	// Store the final result to the output image
	if (depth != 1.0)
		imageStore(finalOutput, ivec2(gl_GlobalInvocationID.xy), vec4(final, 1.0));
	else 
		imageStore(finalOutput, coord, vec4(prev, 1.0));
	
}