#version 450 core

#include "Defines.glsl"

layout(local_size_x = THREAD_GROUP_SIZE, local_size_y = THREAD_GROUP_SIZE) in;

layout(binding = 0, rgba8) uniform writeonly image2D finalOutput;

layout( binding = 1) uniform Data
{
	int firstFrame;
	float padding[3];
} uniforms;

layout(binding = 2) uniform sampler2D in_hdr;
layout(binding = 3) uniform sampler2D in_velocity;
layout(binding = 4) uniform sampler2D in_history;
layout(binding = 5) uniform sampler2D in_depth;


void main()
{
	ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
	ivec2 imgSize = ivec2(imageSize(finalOutput));

	if (coord.x > imgSize.x || coord.y > imgSize.y)
		return;

		const vec2 uv = (vec2(gl_GlobalInvocationID.xy) + vec2(0.5)) / vec2(imageSize(finalOutput));

	
	vec3 neighborhoodMin = vec3(100000);
	vec3 neighborhoodMax = vec3(-100000);
	vec3 current;
	float bestDepth = 1;

	ivec2 bestPixel = ivec2(0, 0);
	for (int x = -1; x <= 1; ++x)
	{
		for (int y = -1; y <= 1; ++y)
		{
			const ivec2 curPixel = ivec2(gl_GlobalInvocationID.xy) + ivec2(x, y);

			const vec3 neighbor = texelFetch(in_hdr, curPixel, 0).rgb;
			neighborhoodMin = min(neighborhoodMin, neighbor);
			neighborhoodMax = max(neighborhoodMax, neighbor);
			if (x == 0 && y == 0)
			{
				current = neighbor;
			}

			const float depth = texelFetch(in_depth, curPixel, 0).r;
			if (depth < bestDepth)
			{
				bestDepth = depth;
				bestPixel = curPixel;
			}
		}
	}
	
	const vec2 velocity = vec2(0) ;// = texelFetch(in_velocity, bestPixel, 0).xy / 4.0;

	const vec2 prevUV = uv + velocity;

	vec3 history = textureLod(in_history, prevUV, 0).rgb;

	history.rgb = clamp(history.rgb, neighborhoodMin, neighborhoodMax);

	vec2 res = vec2(imageSize(finalOutput));

	float subpixelCorrection = fract(max(abs(velocity.x) * res.x, abs(velocity.y) * res.y)) * 0.5f;

	float blendfactor = clamp(mix(0.05f, 0.8f, subpixelCorrection), 0.0,1.0);

	vec3 resolved = mix(history.rgb, current.rgb, blendfactor);

	imageStore(finalOutput, ivec2(gl_GlobalInvocationID.xy), vec4(resolved, 1.0));


	
	/*vec2 velocity = texture(in_velocity, uv).rg;

	vec2 texelSize = vec2(1.0) / vec2(textureSize(in_hdr, 0).xy);

	vec3 currentSample = texture(in_hdr, uv).rgb;
	vec3 historySample = texture(in_history, uv - velocity).rgb;

	vec3 NearColor0 = texture(in_hdr, uv + vec2(1, 0) * texelSize).xyz;
    vec3 NearColor1 = texture(in_hdr, uv + vec2(0, 1) * texelSize).xyz;
    vec3 NearColor2 = texture(in_hdr, uv + vec2(-1, 0) * texelSize).xyz;
    vec3 NearColor3 = texture(in_hdr, uv + vec2(0, -1) * texelSize).xyz;

	vec3 BoxMin = min(currentSample, min(NearColor0, min(NearColor1, min(NearColor2, NearColor3))));
    vec3 BoxMax = max(currentSample, max(NearColor0, max(NearColor1, max(NearColor2, NearColor3))));;

	historySample = clamp(historySample, BoxMin, BoxMax);

	float modFactor = 0.9;

	vec3 resolved = mix(currentSample, historySample, modFactor);

	imageStore(finalOutput, ivec2(gl_GlobalInvocationID.xy), vec4(resolved, 1.0));*/

}